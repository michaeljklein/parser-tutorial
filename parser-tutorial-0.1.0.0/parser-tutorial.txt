-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package parser-tutorial
@version 0.1.0.0


-- | Motivation: Ok so we want to parse stuff. First of all, what does it
--   mean to parse something? According to Google, "Parse (verb): analyze
--   (a sentence) into its parts and describe their syntactic roles" So we
--   want to break down, in our case, a string into parts with
--   descriptions. What are some things we want to cover with our parser? -
--   We want to be able to parse small pieces with descriptions - We want
--   to be able to combine small parsers into larger parsers - If a parser
--   fails, we should be able to try something else
--   
--   Ok, these are pretty strightforward. Here's a type that models this:
--   
--   <pre>
--   <a>Parse</a> object :: <a>String</a> -&gt; <a>Either</a> <a>String</a> (<a>String</a>, object)
--   </pre>
--   
--   In words, something that parses an <tt>object</tt> is a function that
--   takes a <a>String</a> and either fails (returns the input) or succeeds
--   and returns the leftover <a>String</a> and the <tt>object</tt>.
--   
--   Quick note: In Haskell, a <a>String</a> is a list of <a>Char</a>'s,
--   <tt>[<a>Char</a>]</tt>, and <tt><a>Either</a> left right = <a>Left</a>
--   left | <a>Right</a> right</tt>.
--   
--   A couple examples:
--   
--   <pre>
--   "abc" = [<tt>a</tt>, <tt>b</tt>, <tt>c</tt>]
--   <a>Left</a> "Hi, I'm <tt>left</tt>"
--   <a>Right</a> "Hi, I'm <tt>right</tt>"
--   </pre>
--   
--   In Haskell, we have the following definitions:
--   
--   <pre>
--   type String = [Char]
--   
--   data Either l r = Left l | Right r
--   </pre>
--   
--   Ok, now that we know what we want, how do we implement it? I use a
--   "newtype" which is just a wrapper type:
module Tutorial

-- | What does this mean? It means "Parse a" has the constructor
--   <a>Parser</a>, takes a function of that long type, and you can pull
--   out the internal function with the function <a>runParser</a>. So if we
--   have a parsing function:
--   
--   <pre>
--   iParse :: String -&gt; Either String (String, Stuff)
--   </pre>
--   
--   we can do <tt><a>Parser</a> iParse :: <a>Parse</a> Stuff</tt> (the
--   fancy notation "::" can be translated as "has the type").
newtype Parse a
Parser :: (String -> Either String (String, a)) -> Parse a
[runParser] :: Parse a -> String -> Either String (String, a)

-- | <a>Dog</a>s have names
data Dog
Dog :: String -> Dog
[dogName] :: Dog -> String

-- | For example, if all animals have a name and Fido is an animal, then
--   Fido has a name
--   
--   <pre>
--   myPet = Dog "Fido"
--   </pre>
myPet :: Dog

-- | This is equivalent to defining that all <a>Animal</a>s have names
class Animal animal

-- | The full type is:
--   
--   <pre>
--   getName :: Animal animal =&gt; animal -&gt; String
--   </pre>
--   
--   Which can be read as: "if <tt>animal</tt> is an <a>Animal</a>, then we
--   can get it's name, which is a <a>String</a>"
getName :: Animal animal => animal -> String

-- | All you do to run a parser is pull the function out of the
--   <a>Parse</a> type, run it on the string, and drop the leftovers It
--   would be nice to have it return an error, but it would get more messy
--   and this is supposed to be a pretty clean introduction.
--   
--   Here's a verbose implementation:
--   
--   <pre>
--   <a>parse</a> (<a>Parser</a> p) s = mapEither onlySecond (p s)
--   </pre>
--   
--   or my actual Haskell implementaion:
--   
--   <pre>
--   <a>parse</a> = <a>fmap</a> (<a>fmap</a> <a>snd</a>) <a>.</a> <a>runParser</a>
--   </pre>
parse :: Parse a -> String -> Either String a

-- | Accept any <a>Char</a> the predicate passes for Here's how this works:
--   <a>charP</a> takes a test or "predicate".
--   
--   When the parser is run, if the test passes for the first character in
--   the string then return the character and the rest of the string as
--   leftover. If the test fails or there is no first character, then it
--   fails.
--   
--   <pre>
--   <a>charP</a> p = <a>Parser</a> go
--     where
--       go [] = <a>Left</a> []
--       go (c:cs) | p c       = <a>Right</a> (cs, c )
--                 | <a>otherwise</a> = <a>Left</a>  (c : cs)
--   </pre>
charP :: (Char -> Bool) -> Parse Char

-- | Match the specified <a>Char</a>
--   
--   (This is just <tt><a>charP</a> (<a>==</a> givenCharacter)</tt>)
--   
--   <pre>
--   <a>char</a> = <a>charP</a> <a>.</a> (<a>==</a>)
--   </pre>
char :: Char -> Parse Char

-- | Match any digit `Char
--   
--   <pre>
--   <a>digit</a> = <a>charP</a> <a>isDigit</a>
--   </pre>
digit :: Parse Char

-- | Since <tt><a>const</a> <a>True</a></tt> is a function that always
--   returns <a>True</a>, this parses any single character
--   
--   <pre>
--   <a>anyChar</a> = <a>charP</a> (<a>const</a> <a>True</a>)
--   </pre>
anyChar :: Parse Char

-- | Succeeds only if the provided parser fails (does not consume any
--   input). What this does is run the given parser (<tt>p</tt>):
--   
--   If <tt>p</tt> succeeds, then this parser fails, rewinding the input to
--   before <tt>p</tt>
--   
--   If <tt>p</tt> fails, then this parser succeeds and returns all of the
--   input as leftovers
--   
--   Note that we never defined <a>mapM</a>. That's because we get it for
--   free by defining <a>return</a> and (<a>&gt;&gt;=</a>).
--   
--   <pre>
--   <a>notP</a> p = <a>Parser</a> $ <a>runParser</a> p <a>&gt;&gt;=</a> go
--     where
--       go (<a>Left</a> _) s = <a>Right</a> (s, `()`)
--       go       _  s = <a>Left</a>   s
--   </pre>
notP :: Parse a -> Parse ()

-- | <a>mapM</a> maps the function and combines all the monads inside.
--   
--   For example:
--   
--   <pre>
--   <a>map</a> <a>char</a> [<tt>a</tt>, <tt>b</tt>, <tt>c</tt>] = [<a>char</a> <tt>a</tt>, <a>char</a> <tt>b</tt>, <a>char</a> <tt>c</tt>]
--   </pre>
--   
--   This isn't too helpful since now we have to somehow run all the
--   <a>char</a> parsers and collect the results. <a>mapM</a> does exactly
--   this (remember that <tt><a>String</a> = [<a>Char</a>]</tt>).
--   
--   <pre>
--   <a>string</a> = <a>mapM</a> <a>char</a>
--   </pre>
string :: String -> Parse String

-- | Parse any <a>Char</a> in the given <a>String</a>
elemP :: String -> Parse Char

-- | One more function, this one is also free from <a>return</a> and
--   (<a>&gt;&gt;=</a>):
--   
--   <tt>parseA <a>&gt;&gt;</a> parseB</tt> parses A, but tosses the result
--   before parsing B
--   
--   <pre>
--   (&gt;&gt;) :: <a>Parse</a> a -&gt; <a>Parse</a> b -&gt; <a>Parse</a> b
--   </pre>
--   
--   This is like (<a>&gt;&gt;</a>), but backwards.
--   
--   <tt>parseA <a>&lt;&lt;</a> parseB</tt> parses A, then B, but tosses B
--   
--   If you want to understand how it works:
--   
--   <pre>
--   <a>liftM2</a> :: (a -&gt; b -&gt; c) -&gt; <a>Parse</a> a -&gt; <a>Parse</a> b -&gt; <a>Parse</a> c
--   <a>liftM2</a> func parser1 parser2 = run parser1, run parser2, return their results combined with func
--   </pre>
--   
--   Now <tt><a>liftM2</a> <a>const</a></tt> makes sense. It runs both
--   parsers, but <tt><a>const</a> a b = a</tt> so it tosses the result of
--   the second parser.
--   
--   <pre>
--   (<a>&lt;&lt;</a>) = <a>liftM2</a> <a>const</a>
--   </pre>
(<<) :: Monad m => m a -> m b -> m a

-- | Parse any single space
--   
--   <pre>
--   <a>space</a> = <a>charP</a> <a>isSpace</a>
--   </pre>
space :: Parse Char

-- | Isn't this pretty?
--   
--   <pre>
--   <a>inParens</a> p = <a>char</a> '(' <a>&gt;&gt;</a> p <a>&lt;&lt;</a> <a>char</a> ')'
--   </pre>
inParens :: Parse a -> Parse a

-- | Parse a series of alpha characters
--   
--   <pre>
--   <a>word</a> = <a>some</a> <a>$</a> <a>charP</a> <a>isAlpha</a>
--   </pre>
word :: Parse String

-- | In words: "the input must start with 'Name ', but once we know it's
--   there, just toss it and parse a word"
--   
--   <pre>
--   <a>name</a> = <a>string</a> "Name " <a>&gt;&gt;</a> <a>word</a>
--   </pre>
name :: Parse String

-- | Now let's write a simple parser for something like
--   
--   <pre>
--   "Class (Name NamedThing)"
--   </pre>
--   
--   where we only want <a>Class</a> and <a>NamedThing</a>:
--   
--   <pre>
--   <a>classType</a> = do
--     className &lt;- <a>word</a>            -- get a word and call it <tt>className</tt>
--     <a>many</a> <a>space</a>                   -- get a bunch of spaces, but toss them, they're in the way
--     typeName  &lt;- <a>inParens</a> <a>name</a>   -- get a name that's in parentheses and call it <tt>typeName</tt>
--     <a>return</a> (className, typeName)  -- return what you've gotten in a nice tuple
--   </pre>
--   
--   examples: (almost exact)
--   
--   <pre>
--   parse classType "Spoken  (Name Kid)"      = (<a>Spoken</a>, <a>Kid</a>)
--   parse classType "Monad   (Name Function)" = (<a>Monad</a>,  <a>Function</a>)
--   parse classType "Word1   (Name Word2)"    = (<a>Word1</a>,  <a>Word2</a>)
--   </pre>
classType :: Parse (String, String)

-- | An Expression with type <tt>a</tt> can be:
data Expr a

-- | A numeric literal, e.g. <tt>1337</tt> or <tt>42</tt>
[Lit] :: a -> Expr a

-- | A sum of expressions
[Sum] :: [Expr a] -> Expr a

-- | A literal is:
--   
--   <pre>
--   <a>parseLit</a> = do
--     <a>some</a> <a>space</a>                           -- toss some spaces
--     digits &lt;- <a>some</a> <a>digit</a>                 -- the literal's digits are just "some digits"
--     <a>return</a> <a>.</a> <a>Lit</a> <a>.</a> toNum <a>.</a> <a>read</a> <a>$</a> digits -- return the digits, read and converted to a nice <a>Num</a> type, then wrapped in the <a>Lit</a> constructor
--       where
--         toNum :: <a>Num</a> a =&gt; <a>Int</a> -&gt; a
--         toNum = <a>fromInteger</a> <a>.</a> <a>toEnum</a>
--   </pre>
parseLit :: Num a => Parse (Expr a)

-- | A sum is:
--   
--   <pre>
--   <a>parseSum</a> = do
--     <a>char</a> '('                     -- starts with an opening parentheses
--     <a>char</a> '+'                       -- then there's a <a>+</a>
--     subExprs &lt;- <a>some</a> <a>parseExpr</a>   -- then there are some subexpressions, each one is either a literal or a sum
--     <a>char</a> ')'                     -- end with a closing parentheses
--     <a>return</a> <a>$</a> <a>Sum</a> subExprs        -- return the subexpressions wrapped in our <a>Sum</a> constructor
--   </pre>
parseSum :: Num a => Parse (Expr a)

-- | An expression is:
--   
--   <pre>
--   <a>parseExpr</a> = <a>parseLit</a> <a>|</a> <a>parseSum</a> -- either a literal or a sum
--   </pre>
parseExpr :: Num a => Parse (Expr a)

-- | To evaluate an expression:
--   
--   <pre>
--   <a>eval</a> (<a>Lit</a> x ) = x                  -- we unwrap literals
--   <a>eval</a> (<a>Sum</a> xs) = <a>sum</a> (<a>fmap</a> <a>eval</a> xs) -- and sum the evaluated subexpressions in a <a>Sum</a>
--   </pre>
eval :: Num a => Expr a -> a

-- | (This is for the test suite, but defined here because I haven't moved
--   it yet.) Convert a
--   
--   <pre>
--   <a>String</a> -&gt; (<a>Bool</a>, <a>Int</a>, a)
--   </pre>
--   
--   function into a parser by:
--   
--   <ul>
--   <li>If the <a>Bool</a> is <a>False</a>, consume no input</li>
--   <li>If the <a>Bool</a> is <a>True</a>, consume the <a>Int</a>
--   characters of input if available, else fail</li>
--   </ul>
toParser :: (String -> (Bool, Int, a)) -> Parse a
instance GHC.Classes.Ord a => GHC.Classes.Ord (Tutorial.Expr a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Tutorial.Expr a)
instance GHC.Show.Show a => GHC.Show.Show (Tutorial.ShortList a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Tutorial.ShortList a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Tutorial.ShortList a)
instance GHC.Show.Show a => GHC.Show.Show (Tutorial.Parse a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Tutorial.Parse a)
instance Test.QuickCheck.Checkers.EqProp a => Test.QuickCheck.Checkers.EqProp (Tutorial.Parse a)
instance GHC.Classes.Eq a => Test.QuickCheck.Checkers.EqProp (Tutorial.Expr a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Tutorial.ShortList a)
instance (GHC.Num.Num a, GHC.Classes.Ord a, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Tutorial.Expr a)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Tutorial.Expr a)
instance Tutorial.Animal Tutorial.Dog
instance GHC.Base.Functor Tutorial.Parse
instance GHC.Base.Applicative Tutorial.Parse
instance GHC.Base.Monad Tutorial.Parse
instance GHC.Base.Alternative Tutorial.Parse


-- | Motivation:
--   
--   So you learned all about parsing, but want to be sure it all works?
--   Welcome to a less beginner-friendly tutorial on testing in Haskell.
module Test.Tutorial
data SomeParser
SomeParser :: (String, Gen (Parse a)) -> SomeParser
someReturn :: (EqProp a, Show a, Arbitrary a, CoArbitrary a) => a -> SomeParser
rGen :: a -> Gen a
testSomeParser :: (forall a. (EqProp a, Show a, Arbitrary a, CoArbitrary a) => Parse a -> TestBatch) -> SomeParser -> Gen TestBatch
testSomeParser2 :: (forall a b. (EqProp a, Show a, Arbitrary a, CoArbitrary a, EqProp b, Show b, Arbitrary b, CoArbitrary b) => Parse (a, b) -> TestBatch) -> SomeParser -> SomeParser -> Gen TestBatch
testSomeParser3 :: (forall a b c. (EqProp a, Show a, Arbitrary a, CoArbitrary a, EqProp b, Show b, Arbitrary b, CoArbitrary b, EqProp c, Show c, Arbitrary c, CoArbitrary c) => Parse (a, b, c) -> TestBatch) -> SomeParser -> SomeParser -> SomeParser -> Gen TestBatch
prop_parseIsFunctor :: SomeParser -> SomeParser -> SomeParser -> Gen TestBatch
prop_parseIsApplicative :: SomeParser -> SomeParser -> SomeParser -> Gen TestBatch
prop_parseIsMonad :: SomeParser -> SomeParser -> SomeParser -> Gen TestBatch
prop_parseIsMonadFunctor :: SomeParser -> SomeParser -> Gen TestBatch
prop_parseIsAlternative :: SomeParser -> Gen TestBatch
consumes :: Int -> Parse a -> String -> Bool

-- | Test that a char parser consumes one char if the predicate is true on
--   the first character of the string and 0 otherwise
testCharParser :: (Char -> Bool) -> Parse a -> String -> Bool
prop_charP :: (Char -> Bool) -> String -> Bool
prop_char :: Char -> String -> Bool
prop_digit :: String -> Bool
prop_anyChar :: String -> Bool
prop_string :: String -> String -> Bool
prop_notP :: (Arbitrary a, Show a) => Parse a -> String -> Bool
prop_elemP :: String -> String -> Bool
prop_space :: String -> Bool
aParser :: Gen SomeParser
runTests :: IO Bool
instance GHC.Show.Show Test.Tutorial.SomeParser
instance Test.QuickCheck.Property.Testable GHC.Types.Char
instance GHC.Real.Integral a => GHC.Show.Show (Tutorial.Expr a)
instance Test.QuickCheck.Arbitrary.Arbitrary Test.Tutorial.SomeParser
