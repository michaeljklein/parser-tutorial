<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Tutorial</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Tutorial.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Tutorial.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">parser-tutorial-0.1.0.0</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) Michael Klein 2017</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>maintainer</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Tutorial</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Classes</a><ul><li><a href="#g:2">Class applications</a></li></ul></li><li><a href="#g:3">Class instances</a><ul><li><a href="#g:4">Functor instance</a></li><li><a href="#g:5">Applicative instance</a></li><li><a href="#g:6">Monad instance</a></li><li><a href="#g:7">Alternative instance</a></li><li><a href="#g:8">Writing a recursive parser</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Motivation:
Ok so we want to parse stuff. First of all, what does it mean to parse something?
According to Google, &quot;Parse (verb): analyze (a sentence) into its parts and describe their syntactic roles&quot;
So we want to break down, in our case, a string into parts with descriptions.
What are some things we want to cover with our parser?
 - We want to be able to parse small pieces with descriptions
 - We want to be able to combine small parsers into larger parsers
 - If a parser fails, we should be able to try something else</p><p>Ok, these are pretty strightforward. Here's a type that models this:</p><pre> <code><a href="Tutorial.html#t:Parse">Parse</a></code> object :: <code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code> -&gt; <code><a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a></code> <code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code> (<code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code>, object)
</pre><p>In words, something that parses an <code>object</code> is a function that takes a <code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code>
and either fails (returns the input) or succeeds and returns the leftover <code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code> and the <code>object</code>.</p><p>Quick note: In Haskell, a <code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code> is a list of <code><a href="../base-4.9.1.0/Data-Char.html#t:Char">Char</a></code>'s, <code>[<code><a href="../base-4.9.1.0/Data-Char.html#t:Char">Char</a></code>]</code>, and <code><code><a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a></code> left right = <code><a href="../base-4.9.1.0/Data-Either.html#v:Left">Left</a></code> left | <code><a href="../base-4.9.1.0/Data-Either.html#v:Right">Right</a></code> right</code>.</p><p>A couple examples:</p><pre>&quot;abc&quot; = [<code>a</code>, <code>b</code>, <code>c</code>]
<code><a href="../base-4.9.1.0/Data-Either.html#v:Left">Left</a></code> &quot;Hi, I'm <code>left</code>&quot;
<code><a href="../base-4.9.1.0/Data-Either.html#v:Right">Right</a></code> &quot;Hi, I'm <code>right</code>&quot;
</pre><p>In Haskell, we have the following definitions:</p><pre>type String = [Char]

data Either l r = Left l | Right r
</pre><p>Ok, now that we know what we want, how do we implement it? I use a &quot;newtype&quot; which is just a wrapper type:</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">newtype</span> <a href="#t:Parse">Parse</a> a = <a href="#v:Parser">Parser</a> {<ul class="subs"><li><a href="#v:runParser">runParser</a> :: <a href="../base-4.9.1.0/Data-String.html#t:String">String</a> -&gt; <a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a> <a href="../base-4.9.1.0/Data-String.html#t:String">String</a> (<a href="../base-4.9.1.0/Data-String.html#t:String">String</a>, a)</li></ul>}</li><li class="src short"><span class="keyword">data</span> <a href="#t:Dog">Dog</a> = <a href="#v:Dog">Dog</a> {<ul class="subs"><li><a href="#v:dogName">dogName</a> :: <a href="../base-4.9.1.0/Data-String.html#t:String">String</a></li></ul>}</li><li class="src short"><a href="#v:myPet">myPet</a> :: <a href="Tutorial.html#t:Dog">Dog</a></li><li class="src short"><span class="keyword">class</span> <a href="#t:Animal">Animal</a> animal <span class="keyword">where</span><ul class="subs"></ul></li><li class="src short"><a href="#v:parse">parse</a> :: <a href="Tutorial.html#t:Parse">Parse</a> a -&gt; <a href="../base-4.9.1.0/Data-String.html#t:String">String</a> -&gt; <a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a> <a href="../base-4.9.1.0/Data-String.html#t:String">String</a> a</li><li class="src short"><a href="#v:charP">charP</a> :: (<a href="../base-4.9.1.0/Data-Char.html#t:Char">Char</a> -&gt; <a href="../base-4.9.1.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="Tutorial.html#t:Parse">Parse</a> <a href="../base-4.9.1.0/Data-Char.html#t:Char">Char</a></li><li class="src short"><a href="#v:char">char</a> :: <a href="../base-4.9.1.0/Data-Char.html#t:Char">Char</a> -&gt; <a href="Tutorial.html#t:Parse">Parse</a> <a href="../base-4.9.1.0/Data-Char.html#t:Char">Char</a></li><li class="src short"><a href="#v:digit">digit</a> :: <a href="Tutorial.html#t:Parse">Parse</a> <a href="../base-4.9.1.0/Data-Char.html#t:Char">Char</a></li><li class="src short"><a href="#v:anyChar">anyChar</a> :: <a href="Tutorial.html#t:Parse">Parse</a> <a href="../base-4.9.1.0/Data-Char.html#t:Char">Char</a></li><li class="src short"><a href="#v:notP">notP</a> :: <a href="Tutorial.html#t:Parse">Parse</a> a -&gt; <a href="Tutorial.html#t:Parse">Parse</a> ()</li><li class="src short"><a href="#v:string">string</a> :: <a href="../base-4.9.1.0/Data-String.html#t:String">String</a> -&gt; <a href="Tutorial.html#t:Parse">Parse</a> <a href="../base-4.9.1.0/Data-String.html#t:String">String</a></li><li class="src short"><a href="#v:elemP">elemP</a> :: <a href="../base-4.9.1.0/Data-String.html#t:String">String</a> -&gt; <a href="Tutorial.html#t:Parse">Parse</a> <a href="../base-4.9.1.0/Data-Char.html#t:Char">Char</a></li><li class="src short"><a href="#v:-60--60-">(&lt;&lt;)</a> :: <a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; m a -&gt; m b -&gt; m a</li><li class="src short"><a href="#v:space">space</a> :: <a href="Tutorial.html#t:Parse">Parse</a> <a href="../base-4.9.1.0/Data-Char.html#t:Char">Char</a></li><li class="src short"><a href="#v:inParens">inParens</a> :: <a href="Tutorial.html#t:Parse">Parse</a> a -&gt; <a href="Tutorial.html#t:Parse">Parse</a> a</li><li class="src short"><a href="#v:word">word</a> :: <a href="Tutorial.html#t:Parse">Parse</a> <a href="../base-4.9.1.0/Data-String.html#t:String">String</a></li><li class="src short"><a href="#v:name">name</a> :: <a href="Tutorial.html#t:Parse">Parse</a> <a href="../base-4.9.1.0/Data-String.html#t:String">String</a></li><li class="src short"><a href="#v:classType">classType</a> :: <a href="Tutorial.html#t:Parse">Parse</a> (<a href="../base-4.9.1.0/Data-String.html#t:String">String</a>, <a href="../base-4.9.1.0/Data-String.html#t:String">String</a>)</li><li class="src short"><span class="keyword">data</span> <a href="#t:Expr">Expr</a> a <span class="keyword">where</span><ul class="subs"><li><a href="#v:Lit">Lit</a> :: a -&gt; <a href="Tutorial.html#t:Expr">Expr</a> a</li><li><a href="#v:Sum">Sum</a> :: [<a href="Tutorial.html#t:Expr">Expr</a> a] -&gt; <a href="Tutorial.html#t:Expr">Expr</a> a</li></ul></li><li class="src short"><a href="#v:parseLit">parseLit</a> :: <a href="../base-4.9.1.0/Prelude.html#t:Num">Num</a> a =&gt; <a href="Tutorial.html#t:Parse">Parse</a> (<a href="Tutorial.html#t:Expr">Expr</a> a)</li><li class="src short"><a href="#v:parseSum">parseSum</a> :: <a href="../base-4.9.1.0/Prelude.html#t:Num">Num</a> a =&gt; <a href="Tutorial.html#t:Parse">Parse</a> (<a href="Tutorial.html#t:Expr">Expr</a> a)</li><li class="src short"><a href="#v:parseExpr">parseExpr</a> :: <a href="../base-4.9.1.0/Prelude.html#t:Num">Num</a> a =&gt; <a href="Tutorial.html#t:Parse">Parse</a> (<a href="Tutorial.html#t:Expr">Expr</a> a)</li><li class="src short"><a href="#v:eval">eval</a> :: <a href="../base-4.9.1.0/Prelude.html#t:Num">Num</a> a =&gt; <a href="Tutorial.html#t:Expr">Expr</a> a -&gt; a</li><li class="src short"><a href="#v:toParser">toParser</a> :: (<a href="../base-4.9.1.0/Data-String.html#t:String">String</a> -&gt; (<a href="../base-4.9.1.0/Data-Bool.html#t:Bool">Bool</a>, <a href="../base-4.9.1.0/Data-Int.html#t:Int">Int</a>, a)) -&gt; <a href="Tutorial.html#t:Parse">Parse</a> a</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">newtype</span> <a id="t:Parse" class="def">Parse</a> a <a href="src/Tutorial.html#Parse" class="link">Source</a> <a href="#t:Parse" class="selflink">#</a></p><div class="doc"><p>What does this mean? It means &quot;Parse a&quot; has the constructor <a href="Parser.html">Parser</a>,
 takes a function of that long type, and you can pull out the internal function
 with the function <code><a href="Tutorial.html#v:runParser">runParser</a></code>. So if we have a parsing function:</p><pre> iParse :: String -&gt; Either String (String, Stuff)
</pre><p>we can do <code><code><a href="Tutorial.html#v:Parser">Parser</a></code> iParse :: <code><a href="Tutorial.html#t:Parse">Parse</a></code> Stuff</code> (the fancy notation &quot;::&quot; can be translated as &quot;has the type&quot;).</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Parser" class="def">Parser</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:runParser" class="def">runParser</a> :: <a href="../base-4.9.1.0/Data-String.html#t:String">String</a> -&gt; <a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a> <a href="../base-4.9.1.0/Data-String.html#t:String">String</a> (<a href="../base-4.9.1.0/Data-String.html#t:String">String</a>, a)</dfn><div class="doc empty">&nbsp;</div></li></ul></div></td></tr></table></div><div class="subs instances"><p id="control.i:Parse" class="caption collapser" onclick="toggleSection('i:Parse')">Instances</p><div id="section.i:Parse" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Parse:Monad:1" class="instance expander" onclick="toggleSection('i:id:Parse:Monad:1')"></span> <a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a> <a href="Tutorial.html#t:Parse">Parse</a></span> <a href="src/Tutorial.html#line-523" class="link">Source</a> <a href="#t:Parse" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:Parse:Monad:1" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-62--62--61-">(&gt;&gt;=)</a> :: <a href="Tutorial.html#t:Parse">Parse</a> a -&gt; (a -&gt; <a href="Tutorial.html#t:Parse">Parse</a> b) -&gt; <a href="Tutorial.html#t:Parse">Parse</a> b <a href="#v:-62--62--61-" class="selflink">#</a></p><p class="src"><a href="#v:-62--62-">(&gt;&gt;)</a> :: <a href="Tutorial.html#t:Parse">Parse</a> a -&gt; <a href="Tutorial.html#t:Parse">Parse</a> b -&gt; <a href="Tutorial.html#t:Parse">Parse</a> b <a href="#v:-62--62-" class="selflink">#</a></p><p class="src"><a href="#v:return">return</a> :: a -&gt; <a href="Tutorial.html#t:Parse">Parse</a> a <a href="#v:return" class="selflink">#</a></p><p class="src"><a href="#v:fail">fail</a> :: <a href="../base-4.9.1.0/Data-String.html#t:String">String</a> -&gt; <a href="Tutorial.html#t:Parse">Parse</a> a <a href="#v:fail" class="selflink">#</a></p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Parse:Functor:2" class="instance expander" onclick="toggleSection('i:id:Parse:Functor:2')"></span> <a href="../base-4.9.1.0/Data-Functor.html#t:Functor">Functor</a> <a href="Tutorial.html#t:Parse">Parse</a></span> <a href="src/Tutorial.html#line-344" class="link">Source</a> <a href="#t:Parse" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:Parse:Functor:2" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="Tutorial.html#t:Parse">Parse</a> a -&gt; <a href="Tutorial.html#t:Parse">Parse</a> b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="Tutorial.html#t:Parse">Parse</a> b -&gt; <a href="Tutorial.html#t:Parse">Parse</a> a <a href="#v:-60--36-" class="selflink">#</a></p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Parse:Applicative:3" class="instance expander" onclick="toggleSection('i:id:Parse:Applicative:3')"></span> <a href="../base-4.9.1.0/Control-Applicative.html#t:Applicative">Applicative</a> <a href="Tutorial.html#t:Parse">Parse</a></span> <a href="src/Tutorial.html#line-453" class="link">Source</a> <a href="#t:Parse" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:Parse:Applicative:3" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a -&gt; <a href="Tutorial.html#t:Parse">Parse</a> a <a href="#v:pure" class="selflink">#</a></p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="Tutorial.html#t:Parse">Parse</a> (a -&gt; b) -&gt; <a href="Tutorial.html#t:Parse">Parse</a> a -&gt; <a href="Tutorial.html#t:Parse">Parse</a> b <a href="#v:-60--42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="Tutorial.html#t:Parse">Parse</a> a -&gt; <a href="Tutorial.html#t:Parse">Parse</a> b -&gt; <a href="Tutorial.html#t:Parse">Parse</a> b <a href="#v:-42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="Tutorial.html#t:Parse">Parse</a> a -&gt; <a href="Tutorial.html#t:Parse">Parse</a> b -&gt; <a href="Tutorial.html#t:Parse">Parse</a> a <a href="#v:-60--42-" class="selflink">#</a></p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Parse:Alternative:4" class="instance expander" onclick="toggleSection('i:id:Parse:Alternative:4')"></span> <a href="../base-4.9.1.0/Control-Applicative.html#t:Alternative">Alternative</a> <a href="Tutorial.html#t:Parse">Parse</a></span> <a href="src/Tutorial.html#line-671" class="link">Source</a> <a href="#t:Parse" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:Parse:Alternative:4" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:empty">empty</a> :: <a href="Tutorial.html#t:Parse">Parse</a> a <a href="#v:empty" class="selflink">#</a></p><p class="src"><a href="#v:-60--124--62-">(&lt;|&gt;)</a> :: <a href="Tutorial.html#t:Parse">Parse</a> a -&gt; <a href="Tutorial.html#t:Parse">Parse</a> a -&gt; <a href="Tutorial.html#t:Parse">Parse</a> a <a href="#v:-60--124--62-" class="selflink">#</a></p><p class="src"><a href="#v:some">some</a> :: <a href="Tutorial.html#t:Parse">Parse</a> a -&gt; <a href="Tutorial.html#t:Parse">Parse</a> [a] <a href="#v:some" class="selflink">#</a></p><p class="src"><a href="#v:many">many</a> :: <a href="Tutorial.html#t:Parse">Parse</a> a -&gt; <a href="Tutorial.html#t:Parse">Parse</a> [a] <a href="#v:many" class="selflink">#</a></p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Parse:Show:5" class="instance expander" onclick="toggleSection('i:id:Parse:Show:5')"></span> <a href="../base-4.9.1.0/Text-Show.html#t:Show">Show</a> a =&gt; <a href="../base-4.9.1.0/Text-Show.html#t:Show">Show</a> (<a href="Tutorial.html#t:Parse">Parse</a> a)</span> <a href="src/Tutorial.html#line-131" class="link">Source</a> <a href="#t:Parse" class="selflink">#</a></td><td class="doc"><p>Dummy instance for testing</p></td></tr><tr><td colspan="2"><div id="section.i:id:Parse:Show:5" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="../base-4.9.1.0/Data-Int.html#t:Int">Int</a> -&gt; <a href="Tutorial.html#t:Parse">Parse</a> a -&gt; <a href="../base-4.9.1.0/Text-Show.html#t:ShowS">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Tutorial.html#t:Parse">Parse</a> a -&gt; <a href="../base-4.9.1.0/Data-String.html#t:String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Tutorial.html#t:Parse">Parse</a> a] -&gt; <a href="../base-4.9.1.0/Text-Show.html#t:ShowS">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Parse:Arbitrary:6" class="instance expander" onclick="toggleSection('i:id:Parse:Arbitrary:6')"></span> <a href="../QuickCheck-2.9.2/Test-QuickCheck-Arbitrary.html#t:Arbitrary">Arbitrary</a> a =&gt; <a href="../QuickCheck-2.9.2/Test-QuickCheck-Arbitrary.html#t:Arbitrary">Arbitrary</a> (<a href="Tutorial.html#t:Parse">Parse</a> a)</span> <a href="src/Tutorial.html#line-135" class="link">Source</a> <a href="#t:Parse" class="selflink">#</a></td><td class="doc"><p>Use <code><a href="Tutorial.html#v:toParser">toParser</a></code> with an arbitrary function</p></td></tr><tr><td colspan="2"><div id="section.i:id:Parse:Arbitrary:6" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:arbitrary">arbitrary</a> :: <a href="../QuickCheck-2.9.2/Test-QuickCheck-Gen.html#t:Gen">Gen</a> (<a href="Tutorial.html#t:Parse">Parse</a> a) <a href="#v:arbitrary" class="selflink">#</a></p><p class="src"><a href="#v:shrink">shrink</a> :: <a href="Tutorial.html#t:Parse">Parse</a> a -&gt; [<a href="Tutorial.html#t:Parse">Parse</a> a] <a href="#v:shrink" class="selflink">#</a></p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Parse:EqProp:7" class="instance expander" onclick="toggleSection('i:id:Parse:EqProp:7')"></span> <a href="../checkers-0.4.6/Test-QuickCheck-Checkers.html#t:EqProp">EqProp</a> a =&gt; <a href="../checkers-0.4.6/Test-QuickCheck-Checkers.html#t:EqProp">EqProp</a> (<a href="Tutorial.html#t:Parse">Parse</a> a)</span> <a href="src/Tutorial.html#line-139" class="link">Source</a> <a href="#t:Parse" class="selflink">#</a></td><td class="doc"><p>Just unwrap the <code><a href="Tutorial.html#v:Parser">Parser</a></code></p></td></tr><tr><td colspan="2"><div id="section.i:id:Parse:EqProp:7" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61--45--61-">(=-=)</a> :: <a href="Tutorial.html#t:Parse">Parse</a> a -&gt; <a href="Tutorial.html#t:Parse">Parse</a> a -&gt; <a href="../QuickCheck-2.9.2/Test-QuickCheck-Property.html#t:Property">Property</a> <a href="#v:-61--45--61-" class="selflink">#</a></p></div></div></td></tr></table></div></div></div><h1 id="g:1">Classes</h1><div class="doc"><p>Ok, now let's make some combinators for our type. In Haskell, type classes are basically facts.
 Given a fact about an object, you can derive other things.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Dog" class="def">Dog</a> <a href="src/Tutorial.html#Dog" class="link">Source</a> <a href="#t:Dog" class="selflink">#</a></p><div class="doc"><p><code><a href="Tutorial.html#t:Dog">Dog</a></code>s have names</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Dog" class="def">Dog</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:dogName" class="def">dogName</a> :: <a href="../base-4.9.1.0/Data-String.html#t:String">String</a></dfn><div class="doc empty">&nbsp;</div></li></ul></div></td></tr></table></div><div class="subs instances"><p id="control.i:Dog" class="caption collapser" onclick="toggleSection('i:Dog')">Instances</p><div id="section.i:Dog" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Dog:Animal:1" class="instance expander" onclick="toggleSection('i:id:Dog:Animal:1')"></span> <a href="Tutorial.html#t:Animal">Animal</a> <a href="Tutorial.html#t:Dog">Dog</a></span> <a href="src/Tutorial.html#line-212" class="link">Source</a> <a href="#t:Dog" class="selflink">#</a></td><td class="doc"><p>Here, <code><code><a href="Tutorial.html#v:getName">getName</a></code> = <code><a href="Tutorial.html#v:dogName">dogName</a></code></code></p></td></tr><tr><td colspan="2"><div id="section.i:id:Dog:Animal:1" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:getName">getName</a> :: <a href="Tutorial.html#t:Dog">Dog</a> -&gt; <a href="../base-4.9.1.0/Data-String.html#t:String">String</a> <a href="src/Tutorial.html#getName" class="link">Source</a> <a href="#v:getName" class="selflink">#</a></p></div></div></td></tr></table></div></div></div><div class="top"><p class="src"><a id="v:myPet" class="def">myPet</a> :: <a href="Tutorial.html#t:Dog">Dog</a> <a href="src/Tutorial.html#myPet" class="link">Source</a> <a href="#v:myPet" class="selflink">#</a></p><div class="doc"><p>For example, if all animals have a name and Fido is an animal, then Fido has a name</p><pre>myPet = Dog &quot;Fido&quot;
</pre></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a id="t:Animal" class="def">Animal</a> animal <span class="keyword">where</span> <a href="src/Tutorial.html#Animal" class="link">Source</a> <a href="#t:Animal" class="selflink">#</a></p><div class="doc"><p>This is equivalent to defining that all <code><a href="Tutorial.html#t:Animal">Animal</a></code>s have names</p></div><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src"><a href="Tutorial.html#v:getName">getName</a></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:getName" class="def">getName</a> :: animal -&gt; <a href="../base-4.9.1.0/Data-String.html#t:String">String</a> <a href="src/Tutorial.html#getName" class="link">Source</a> <a href="#v:getName" class="selflink">#</a></p><div class="doc"><p>The full type is:</p><pre>getName :: Animal animal =&gt; animal -&gt; String
</pre><p>Which can be read as: &quot;if <code>animal</code> is an <code><a href="Tutorial.html#t:Animal">Animal</a></code>, then we can get it's name, which is a <code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code>&quot;</p></div></div><div class="subs instances"><p id="control.i:Animal" class="caption collapser" onclick="toggleSection('i:Animal')">Instances</p><div id="section.i:Animal" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:ic:Animal:Animal:1" class="instance expander" onclick="toggleSection('i:ic:Animal:Animal:1')"></span> <a href="Tutorial.html#t:Animal">Animal</a> <a href="Tutorial.html#t:Dog">Dog</a></span> <a href="src/Tutorial.html#line-212" class="link">Source</a> <a href="#t:Animal" class="selflink">#</a></td><td class="doc"><p>Here, <code><code><a href="Tutorial.html#v:getName">getName</a></code> = <code><a href="Tutorial.html#v:dogName">dogName</a></code></code></p></td></tr><tr><td colspan="2"><div id="section.i:ic:Animal:Animal:1" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:getName">getName</a> :: <a href="Tutorial.html#t:Dog">Dog</a> -&gt; <a href="../base-4.9.1.0/Data-String.html#t:String">String</a> <a href="src/Tutorial.html#getName" class="link">Source</a> <a href="#v:getName" class="selflink">#</a></p></div></div></td></tr></table></div></div></div><h2 id="g:2">Class applications</h2><div class="doc"><p>Now suppose we want to make a &quot;myFavoriteAnimal&quot; function. Well, we could do the following:</p><pre>myFavoriteDog :: <code><a href="Tutorial.html#t:Dog">Dog</a></code> -&gt; <code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code>
myFavoriteDog (<code><a href="Tutorial.html#t:Dog">Dog</a></code> name) = &quot;My favorite animal is named: &quot; <code><a href="../base-4.9.1.0/GHC-OldList.html#v:-43--43-">++</a></code> name

myFavoriteBird :: Bird -&gt; <code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code>
..
</pre><p>Or, we can make a &quot;classy&quot; function:</p><pre>myFavoriteAnimal :: <code><a href="Tutorial.html#t:Animal">Animal</a></code> animal =&gt; animal -&gt; <code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code>
myFavoriteAnimal namedAnimal = &quot;My favorite animal is named: &quot; <code><a href="../base-4.9.1.0/GHC-OldList.html#v:-43--43-">++</a></code> <code><a href="Tutorial.html#v:getName">getName</a></code> namedAnimal
</pre><p>Whoh, what's that fancy &quot;<code><a href="Tutorial.html#t:Animal">Animal</a></code> animal =&gt; animal&quot; stuff? It means that &quot;animal&quot; must have an instance of the
 <code><a href="Tutorial.html#t:Animal">Animal</a></code> class for it to work with the function. In other words, it works for _every_ animal of the <code><a href="Tutorial.html#t:Animal">Animal</a></code> class.</p></div><div class="doc"><p>Now onto combinator classes. One important class is <code><a href="../base-4.9.1.0/Data-Functor.html#t:Functor">Functor</a></code>, (minimally) defined as so:</p><pre>class <code><a href="../base-4.9.1.0/Data-Functor.html#t:Functor">Functor</a></code> f where
  <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> :: (a -&gt; b) -&gt; f a -&gt; f b
</pre><p>It also has the requirements (Not enforced by Haskell):</p><pre> <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> <code><a href="../base-4.9.1.0/Data-Function.html#v:id">id</a></code> <code><a href="../base-4.9.1.0/Data-Eq.html#v:-61--61-">==</a></code> <code><a href="../base-4.9.1.0/Data-Function.html#v:id">id</a></code>
 <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> (f <code><a href="../base-4.9.1.0/Data-Function.html#v:.">.</a></code> g) <code><a href="../base-4.9.1.0/Data-Eq.html#v:-61--61-">==</a></code> <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> f <code><a href="../base-4.9.1.0/Data-Function.html#v:.">.</a></code> <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> g
</pre><p>What does this mean? Well <code><a href="../base-4.9.1.0/Data-Functor.html#t:Functor">Functor</a></code> takes a type <code>t</code> and converts an <code>a -&gt; b</code> function into a <code>t a -&gt; t b</code> one.</p><p>A common example is the <code><a href="../base-4.9.1.0/GHC-OldList.html#v:map">map</a></code> function:</p><pre> <code><a href="../base-4.9.1.0/GHC-OldList.html#v:map">map</a></code> :: (a -&gt; b) -&gt; [a] -&gt; [b]
</pre><p><code><a href="../base-4.9.1.0/GHC-OldList.html#v:map">map</a></code> takes a function from <code>a</code> to <code>b</code> and a list of elements with type <code>a</code>. It then applies the function to every element
 so the resulting elements are of type <code>b</code>.</p><p>That's basically what <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> does; If you have a way to get from <code>Type1</code> to <code>Type2</code>, you can get from a &quot;container&quot; of <code>Type1</code>'s to a container of <code>Type2</code>'s.</p><p>So what are other &quot;containers&quot;? <code>(<code><a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a></code> left)</code> is a <code><a href="../base-4.9.1.0/Data-Functor.html#t:Functor">Functor</a></code>, with</p><pre> <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> :: (a -&gt; b) -&gt; <code><a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a></code> left a -&gt; <code><a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a></code> left b
</pre><p>A fun example: if we have a function</p><pre> infuriateCoder :: Coder -&gt; AngryCoder
</pre><p>then <code><code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> infuriateCoder</code> can do several things:</p><pre> <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> infuriateCoder :: <code><a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a></code> NonCoder Coder -&gt; <code><a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a></code> NonCoder AngryCoder
 -- Only infuriate coders, we'd need another function for NonCoder's

 <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> infuriateCoder :: RoomFullOf Coder -&gt; RoomFullOf AngryCoder
 -- Infuriate everyone in the room, who happen to all be Coders
</pre><p>Here's where it starts to get really neat. What if we have a <code>RoomFullOf (<code><a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a></code> NonCoder Coder)</code> and we want to infuriate all the coders in the room?
 That's just:</p><pre> <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> (<code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> infuriateCoder) :: RoomFullOf (<code><a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a></code> NonCoder Coder) -&gt; RoomFullOf (<code><a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a></code> NonCoder AngryCoder)
</pre><p>Whoh! What happened there? Well let's look at the type of <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> for <code>RoomFullOf a</code>:</p><pre> <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> :: (a -&gt; b) -&gt; RoomFullOf a -&gt; RoomFullOf b
</pre><p>Ah, so since <code><code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> infuriateCoder</code> works on <code><code><a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a></code> NonCoder Coder</code>, <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> can also apply it to everyone in the room.</p><p>What about those requirements? What do those mean?</p><pre> <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> <code><a href="../base-4.9.1.0/Data-Function.html#v:id">id</a></code> <code><a href="../base-4.9.1.0/Data-Eq.html#v:-61--61-">==</a></code> <code><a href="../base-4.9.1.0/Data-Function.html#v:id">id</a></code>                   -- means that fmapping the identity to all the objects in &quot;t object&quot; should do nothing
 <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> (f <code><a href="../base-4.9.1.0/Data-Function.html#v:.">.</a></code> g) <code><a href="../base-4.9.1.0/Data-Eq.html#v:-61--61-">==</a></code> <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> f <code><a href="../base-4.9.1.0/Data-Function.html#v:.">.</a></code> <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> g -- means that fmapping one function then another is the same as fmapping &quot;both at once&quot;
</pre><p>So <code><a href="../base-4.9.1.0/Data-Functor.html#t:Functor">Functor</a></code> is really useful, it allows us to get inside some type and modify what it contains.</p><p>How can we apply this to a parser and what can it help with?</p><p>Well the type of <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> for <code><a href="Tutorial.html#t:Parse">Parse</a></code> is:</p><pre> <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> :: (a -&gt; b) -&gt; <code><a href="Tutorial.html#t:Parse">Parse</a></code> a -&gt; <code><a href="Tutorial.html#t:Parse">Parse</a></code> b
</pre><p>Here's an example:</p><pre> translateInsult :: EnglishInsult -&gt; GermanInsult
 parseEnglishInsult :: <code><a href="Tutorial.html#t:Parse">Parse</a></code> EnglishInsult
 <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> translateInsult parseEnglishInsult :: <code><a href="Tutorial.html#t:Parse">Parse</a></code> GermanInsult
</pre><p>This means that we can take something that works with the results of a parser and inject it into that parser.</p><p>This allows us to easily package the post-processing into our parser. Here's a slightly more practical example:</p><pre> toJSON :: Account -&gt; JSON Account

 parseAccount :: <code><a href="Tutorial.html#t:Parse">Parse</a></code> Account

 parseAccountJSON :: <code><a href="Tutorial.html#t:Parse">Parse</a></code> (JSON Account)
 parseAccountJSON = <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> toJSON parseAccount
</pre><p>Now we can write <code>parseAccount</code> without having to worry about JSON conversion and convert to JSON without worrying about parsing.</p><p>All good stuff.</p></div><h1 id="g:3">Class instances</h1><h2 id="g:4">Functor instance</h2><div class="doc"><p>Now the actual Functor instance:</p><pre>instance <code><a href="../base-4.9.1.0/Data-Functor.html#t:Functor">Functor</a></code> <code><a href="Tutorial.html#t:Parse">Parse</a></code> where
  <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> :: (a -&gt; b) -&gt; <code><a href="Tutorial.html#t:Parse">Parse</a></code> a -&gt; <code><a href="Tutorial.html#t:Parse">Parse</a></code> b
  <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> f (<code><a href="Tutorial.html#v:Parser">Parser</a></code> p) = <code><a href="Tutorial.html#v:Parser">Parser</a></code> (<code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> (<code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> f) . p)
</pre><p>To begin to make sense of this, here's what's going on:</p><pre> <code><a href="Tutorial.html#v:Parser">Parser</a></code> (<code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> (<code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> f) . p) :: <code><a href="Tutorial.html#t:Parse">Parse</a></code> b
         <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> (<code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> f) . p  :: <code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code> -&gt; <code><a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a></code> <code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code> (<code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code>, b)
         <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> (<code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> f)      :: <code><a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a></code> <code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code> (<code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code>, a) -&gt; <code><a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a></code> <code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code> (<code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code>, b)
               <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> f       :: (<code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code>, a) -&gt; (<code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code>, b)
                    f       :: a -&gt; b
</pre><p>Now, we want to get to the &quot;a&quot; and apply &quot;f&quot; to it so we:</p><pre>   Compose with _: &quot;_ . p&quot;, where _ :: Either String (String, a) -&gt; Either String (String, b)
   fmap _: &quot;fmap _ . p&quot;, where _ :: (String, a) -&gt; (String, b)
   fmap _: &quot;fmap (fmap _) . p&quot;, where _ :: a -&gt; b
   Now we just need to replace '_' with <code>f</code>, which has type &quot;a -&gt; b&quot;!
</pre><p>Note that <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> automatically changes instances twice:</p><pre> <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> :: ((<code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code>, a) -&gt; (<code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code>, b)) -&gt; Either <code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code> (<code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code>, a) -&gt; Either <code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code> (<code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code>, b)
 <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> :: (a -&gt; b) -&gt; (<code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code>, a) -&gt; (<code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code>, b)
</pre><p>It's neat, but all this bouncing around with abstractions can be a bit intense. Don't be afraid to take a break here to breathe.</p></div><h2 id="g:5">Applicative instance</h2><div class="doc"><p>Now you might be thinking: &quot;ok, ok, but this isn't anything too crazy. I could do that manually without the Functor instance and still be O.K.&quot;
 You're right, and I'm not going to pretend that you should use Haskell or monadic parsers just because you can map over different things.
 Here's where it starts to get really fun :)</p><p>First a use case: What if you had a list of functions ([a -&gt; b]) and a list of elements's ([a]).
 Can you apply all the functions to all the elements?
 Of course you can! Just do [function1 element1, function1 element2, .., function2 element1..]</p><p>Ok so I'm going a lot less in depth for this one. This is called the applicative class and it has two necessary functions:</p><pre>pure :: Applicative f =&gt; a -&gt; f a
(<a href="*">*</a>) Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</pre><p>Here's another application: you have several parsers and a combinator</p><pre>f x1          -&gt; f <code><a href="../base-4.9.1.0/Data-Functor.html#v:-60--36--62-">&lt;$&gt;</a></code> x1                      :: <code><a href="../base-4.9.1.0/Control-Applicative.html#t:Applicative">Applicative</a></code> f =&gt; (                  a1 -&gt; b)                            f a1 -&gt; f b
f x1 x2       -&gt; f <code><a href="../base-4.9.1.0/Data-Functor.html#v:-60--36--62-">&lt;$&gt;</a></code> x1 <code><a href="../base-4.9.1.0/Control-Applicative.html#v:-60--42--62-">&lt;*&gt;</a></code> x2               :: <code><a href="../base-4.9.1.0/Control-Applicative.html#t:Applicative">Applicative</a></code> f =&gt; (            a2 -&gt; a1 -&gt; b)                 -&gt; f a2 -&gt; f a1 -&gt; f b
f x1 x2 x3    -&gt; f <code><a href="../base-4.9.1.0/Data-Functor.html#v:-60--36--62-">&lt;$&gt;</a></code> x1 <code><a href="../base-4.9.1.0/Control-Applicative.html#v:-60--42--62-">&lt;*&gt;</a></code> x2 <code><a href="../base-4.9.1.0/Control-Applicative.html#v:-60--42--62-">&lt;*&gt;</a></code> x3        :: <code><a href="../base-4.9.1.0/Control-Applicative.html#t:Applicative">Applicative</a></code> f =&gt; (      a3 -&gt; a2 -&gt; a1 -&gt; b)         -&gt; f a3 -&gt; f a2 -&gt; f a1 -&gt; f b
f x1 x2 x3 x4 -&gt; f <code><a href="../base-4.9.1.0/Data-Functor.html#v:-60--36--62-">&lt;$&gt;</a></code> x1 <code><a href="../base-4.9.1.0/Control-Applicative.html#v:-60--42--62-">&lt;*&gt;</a></code> x2 <code><a href="../base-4.9.1.0/Control-Applicative.html#v:-60--42--62-">&lt;*&gt;</a></code> x3 <code><a href="../base-4.9.1.0/Control-Applicative.html#v:-60--42--62-">&lt;*&gt;</a></code> x4 :: <code><a href="../base-4.9.1.0/Control-Applicative.html#t:Applicative">Applicative</a></code> f =&gt; (a4 -&gt; a3 -&gt; a2 -&gt; a1 -&gt; b) -&gt; f a4 -&gt; f a3 -&gt; f a2 -&gt; f a1 -&gt; f b
</pre><p>Do you see the pattern? <code><a href="../base-4.9.1.0/Control-Applicative.html#t:Applicative">Applicative</a></code> allows arbitrary extensions of <code><a href="../base-4.9.1.0/Data-Functor.html#t:Functor">Functor</a></code>.</p><p>Here's an example use case:</p><pre> (<code><a href="../base-4.9.1.0/Prelude.html#v:-43-">+</a></code>) <code><a href="../base-4.9.1.0/Data-Functor.html#v:-60--36--62-">&lt;$&gt;</a></code> parseInt <code><a href="../base-4.9.1.0/Control-Applicative.html#v:-60--42--62-">&lt;*&gt;</a></code> parseInt
</pre><p>parses two integers and returns their sum.</p><p>Or</p><pre> (,) <code><a href="../base-4.9.1.0/Data-Functor.html#v:-60--36--62-">&lt;$&gt;</a></code> parseA <code><a href="../base-4.9.1.0/Control-Applicative.html#v:-60--42--62-">&lt;*&gt;</a></code> parseB = parseAB
</pre><p>parses a tuple of <code>(A, B)</code></p><p>If they have the above types and follow these rules, it's a valid instance</p><pre>identity:     pure id <a href="*">*</a> v = v
                          = [id] <a href="*">*</a> [1,2,3] = [id 1, id 2, id 3] = [1,2,3]

homomorphism: pure f <a href="*">*</a> pure x = pure (f x)
  = pure f <a href="*">*</a> pure x = [f] <a href="*">*</a> [x] = [f x] = pure (f x)

composition:  pure (.) <a href="*">*</a> u <a href="*">*</a> v <a href="*">*</a> w = u <a href="*">*</a> (v <a href="*">*</a> w)

interchange:  u <a href="*">*</a> pure y = pure ($ y) <a href="*">*</a> u
  = u <a href="*">*</a> [y] = [u y] = [($ y)] <a href="*">*</a> u = pure ($ y) <a href="*">*</a> u
</pre><pre>instance Applicative [] where
    pure :: a -&gt; [a]
    pure x    = [x]

    (<a href="*">*</a>) :: [a -&gt; b] -&gt; [a] -&gt; [b]
    fs <a href="*">*</a> xs = [f x | f &lt;- fs, x &lt;- xs]
</pre></div><div class="doc"><p>Now for the actual instance for <code><a href="Tutorial.html#t:Parse">Parse</a></code>:</p><pre>instance <code><a href="../base-4.9.1.0/Control-Applicative.html#t:Applicative">Applicative</a></code> <code><a href="Tutorial.html#t:Parse">Parse</a></code> where
  -- <code><code><a href="../base-4.9.1.0/Control-Applicative.html#v:pure">pure</a></code> x</code> is a parser that consumes no input and always returns <code>x</code>
  <code><a href="../base-4.9.1.0/Control-Applicative.html#v:pure">pure</a></code> :: a -&gt; <code><a href="Tutorial.html#t:Parse">Parse</a></code> a
  <code><a href="../base-4.9.1.0/Control-Applicative.html#v:pure">pure</a></code> = <code><a href="Tutorial.html#v:Parser">Parser</a></code> <code><a href="../base-4.9.1.0/Data-Function.html#v:.">.</a></code> (<code><a href="../base-4.9.1.0/Data-Either.html#v:Right">Right</a></code> <code><a href="../base-4.9.1.0/Data-Function.html#v:.">.</a></code>) <code><a href="../base-4.9.1.0/Data-Function.html#v:.">.</a></code> <code><a href="../base-4.9.1.0/Data-Function.html#v:flip">flip</a></code> (,)
  -- here's an alternative implementation:
  -- <code><a href="../base-4.9.1.0/Control-Applicative.html#v:pure">pure</a></code> x = <code><a href="Tutorial.html#v:Parser">Parser</a></code> $ s -&gt; <code><a href="../base-4.9.1.0/Data-Either.html#v:Right">Right</a></code> (s, x)

  -- If the first parser passes, apply its result to the result of the second parser
  -- E.g. <code><code><a href="Tutorial.html#t:Parse">Parse</a></code> (Word -&gt; Definition) -&gt; <code><a href="Tutorial.html#t:Parse">Parse</a></code> Word -&gt; <code><a href="Tutorial.html#t:Parse">Parse</a></code> Definition</code>

  -- If the first parser reads a dictionary to get <code>Word -&gt; Definition</code> mappings
  --  and the second reads a word, they may be combined to make a parser that
  --  reads a word *and* looks up its definition.
  --
  -- That means that if either one fails, you will not get a result.
  -- (One bug I found made it so when looking up the word failed,
  -- the parser forgot to let you know it wasn't able to use the given word.)
  --
  -- All the code says is:
  --  Given parser1 that parses a function and parser2 that parses an input:
  --  if parser1 succeeds
  --    then run parser2 and if it succeeds
  --      then return parser1_result_function( parser2_result )
  --      else fail
  --    else fail
  --
  (<a href="*">*</a>) :: <code><a href="Tutorial.html#t:Parse">Parse</a></code> (a -&gt; b) -&gt; <code><a href="Tutorial.html#t:Parse">Parse</a></code> a -&gt; <code><a href="Tutorial.html#t:Parse">Parse</a></code> b
  <code><a href="Tutorial.html#v:Parser">Parser</a></code> f <code><a href="../base-4.9.1.0/Control-Applicative.html#v:-60--42--62-">&lt;*&gt;</a></code> <code><a href="Tutorial.html#v:Parser">Parser</a></code> x = <code><a href="Tutorial.html#v:Parser">Parser</a></code> <code><a href="../base-4.9.1.0/Data-Function.html#v:-36-">$</a></code> combine <code><a href="../base-4.9.1.0/Data-Function.html#v:.">.</a></code> f
    where
      combine (<code><a href="../base-4.9.1.0/Data-Either.html#v:Left">Left</a></code>   s1     ) = <code><a href="../base-4.9.1.0/Data-Either.html#v:Left">Left</a></code>      s1
      combine (<code><a href="../base-4.9.1.0/Data-Either.html#v:Right">Right</a></code> (s2, f')) = <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> (<code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> f') (x s2)
</pre></div><h2 id="g:6">Monad instance</h2><div class="doc"><p>Here's one way to understand the bind function (<code><a href="../base-4.9.1.0/Control-Monad.html#v:-62--62--61-">&gt;&gt;=</a></code>):</p><pre>(<code><a href="../base-4.9.1.0/Control-Monad.html#v:-62--62--61-">&gt;&gt;=</a></code>)    :: t a -&gt; (a -&gt; t b) -&gt; t b
passedTo ::   a -&gt; (a -&gt;   b) -&gt;   b
x `passedTo` f = f x
</pre><p>That is, bind is just <code>passedTo</code> where the function result is somehow encapsulated
 You may not be able to break the encapsulation, but you can often still apply a function.</p><p>Here's an example:</p><pre> (<code><a href="../base-4.9.1.0/Control-Monad.html#v:-62--62--61-">&gt;&gt;=</a></code>) :: <code><a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a></code> Cat Dog -&gt; (Dog -&gt; <code><a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a></code> Cat Dog) -&gt; <code><a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a></code> Cat Dog
</pre><p>What happens if we have the following?</p><pre>(<code><a href="../base-4.9.1.0/Control-Monad.html#v:-62--62--61-">&gt;&gt;=</a></code>) (<code><a href="../base-4.9.1.0/Data-Either.html#v:Left">Left</a></code> someCat) :: (Dog -&gt; <code><a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a></code> Cat Dog) -&gt; <code><a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a></code> Cat Dog
</pre><p>Well, there's no obvious way to convert a Cat into a Dog, so a reasonable default
 is to skip the <code>Dog -&gt; Either Cat Dog</code> and return <code><code><a href="../base-4.9.1.0/Data-Either.html#v:Left">Left</a></code> someCat</code>.</p><p>In other words, there's likely no good function with the type <code><code><a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a></code> Cat Dog -&gt; Dog</code>,
 since we could have a Cat.</p><p>Thus a sane implementation (actually the default definition for Haskell) for (<code><a href="../base-4.9.1.0/Control-Monad.html#v:-62--62--61-">&gt;&gt;=</a></code>) on <code><a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a></code>
 is the following:</p><pre>(<code><a href="../base-4.9.1.0/Control-Monad.html#v:-62--62--61-">&gt;&gt;=</a></code>) (<code><a href="../base-4.9.1.0/Data-Either.html#v:Left">Left</a></code>  l) f = <code><a href="../base-4.9.1.0/Data-Either.html#v:Left">Left</a></code>     x
(<code><a href="../base-4.9.1.0/Control-Monad.html#v:-62--62--61-">&gt;&gt;=</a></code>) (<code><a href="../base-4.9.1.0/Data-Either.html#v:Right">Right</a></code> r) f = <code><a href="../base-4.9.1.0/Data-Either.html#v:Right">Right</a></code> (f x)
</pre><p>Luckily, this is almost all we need to make a <code><a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a></code> instance for <code><a href="Tutorial.html#t:Parse">Parse</a></code>:</p><pre>instance <code><a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a></code> <code><a href="Tutorial.html#t:Parse">Parse</a></code> where
  -- Still just a parser that returns its argument, no matter what
  <code><a href="../base-4.9.1.0/Control-Monad.html#v:return">return</a></code> :: a -&gt; <code><a href="Tutorial.html#t:Parse">Parse</a></code> a
  <code><a href="../base-4.9.1.0/Control-Monad.html#v:return">return</a></code> = <code><a href="../base-4.9.1.0/Control-Applicative.html#v:pure">pure</a></code>

  -- This is somewhat similar to (<code><a href="../base-4.9.1.0/Control-Applicative.html#v:-60--42--62-">&lt;*&gt;</a></code>)
  --
  -- What it does is runs parser1, then passes the result to the function to get a new parser
  --   E.g. <code><a href="Tutorial.html#v:Parser">Parser</a></code> Password -&gt; (Password -&gt; <code><a href="Tutorial.html#v:Parser">Parser</a></code> Secret) -&gt; <code><a href="Tutorial.html#v:Parser">Parser</a></code> Secret
  -- The first parser reads the password and the second can read a secret
  --  if it has the password. These can be combined to make something that
  --  parses the password and the secret, returning the secret.
  --
  --  This again means that if either fails, you will not get the result.
  --
  --  All the code says is:
  --    Given a parser and a function that can make a new parser out of its result:
  --    If the parser succeeds
  --      then
  --        make a new parser with its result and the function
  --        run the new parser
  --        return the result
  --      else
  --        fail
  --
  (<code><a href="../base-4.9.1.0/Control-Monad.html#v:-62--62--61-">&gt;&gt;=</a></code>) :: <code><a href="Tutorial.html#t:Parse">Parse</a></code> a -&gt; (a -&gt; <code><a href="Tutorial.html#t:Parse">Parse</a></code> b) -&gt; <code><a href="Tutorial.html#t:Parse">Parse</a></code> b
  <code><a href="Tutorial.html#v:Parser">Parser</a></code> x &gt;&gt;= f = Parser $ s -&gt; x s &gt;&gt;= (s', y) -&gt; either (const $ Left s) Right (runParser (f y) s')
</pre></div><div class="doc"><p>You might now be scratching your head, remembering that the weird <code><a href="../base-4.9.1.0/System-IO.html#t:IO">IO</a></code> type in Haskell is a monad.</p><p>Without getting too off track, here's a brief explanation:</p><p>The <code><a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a></code> instance for functions like <code>(a -&gt; b)</code> has a bind with type:</p><pre>(Think that &quot;t&quot; equals &quot;function that returns b&quot; here)
(<code><a href="../base-4.9.1.0/Control-Monad.html#v:-62--62--61-">&gt;&gt;=</a></code>) :: (a -&gt; b) -&gt; (a1 -&gt; a -&gt; b) -&gt; a1 -&gt; b
</pre><p>So then a simple implementation is</p><pre>(<code><a href="../base-4.9.1.0/Control-Monad.html#v:-62--62--61-">&gt;&gt;=</a></code>) f g = x -&gt; g x (f x)
</pre><p>This also turns out to be the default implementaion in Haskell.</p><p>Where am I going with this? Well, part of the idea behind <code><a href="../base-4.9.1.0/System-IO.html#t:IO">IO</a></code> in Haskell is that
 <code><a href="../base-4.9.1.0/System-IO.html#t:IO">IO</a></code> actions may be order sensitive, so you need to make sure they're strung up in a row.</p><p>How do you string up a bunch of effects? Why, might as well have them pass something along, to make sure they're sequenced.
 That's exactly how <code><a href="../base-4.9.1.0/System-IO.html#t:IO">IO</a></code> is implemented behind the scenes (with slightly different names):</p><pre>data IO a = State RealWorld -&gt; (State RealWorld, a)
</pre><p>Some people have said that this isn't pretty or should be hidden from users (it's pretty hard to find in the source).
 However, I think that with it, <code><a href="../base-4.9.1.0/System-IO.html#t:IO">IO</a></code> makes perfect sense. You use monads for <code><a href="../base-4.9.1.0/System-IO.html#t:IO">IO</a></code> because they're an easy way to sequence these
 sorts of functions. So look at the type of bind for <code><a href="../base-4.9.1.0/System-IO.html#t:IO">IO</a></code> then translated:</p><pre>(<code><a href="../base-4.9.1.0/Control-Monad.html#v:-62--62--61-">&gt;&gt;=</a></code>) :: <code><a href="../base-4.9.1.0/System-IO.html#t:IO">IO</a></code> a -&gt; (a -&gt; <code><a href="../base-4.9.1.0/System-IO.html#t:IO">IO</a></code> b) -&gt; <code><a href="../base-4.9.1.0/System-IO.html#t:IO">IO</a></code> b
(<code><a href="../base-4.9.1.0/Control-Monad.html#v:-62--62--61-">&gt;&gt;=</a></code>) :: (State RealWorld -&gt; (State RealWorld, a)) -&gt; (a -&gt; State RealWorld -&gt; (State RealWorld, b)) -&gt; State RealWorld -&gt; (State RealWorld, b)
</pre><p>It's pretty verbose, but compare this to:</p><pre>(<code><a href="../base-4.9.1.0/Control-Monad.html#v:-62--62--61-">&gt;&gt;=</a></code>) :: (s               -&gt;                   a ) -&gt; (a -&gt; s               -&gt;                   b ) -&gt; s               -&gt;                   b
</pre><p>The parallels are clear!</p></div><h2 id="g:7">Alternative instance</h2><div class="doc"><p>Don't forget an alternative instance + explanation!</p></div><div class="top"><p class="src"><a id="v:parse" class="def">parse</a> :: <a href="Tutorial.html#t:Parse">Parse</a> a -&gt; <a href="../base-4.9.1.0/Data-String.html#t:String">String</a> -&gt; <a href="../base-4.9.1.0/Data-Either.html#t:Either">Either</a> <a href="../base-4.9.1.0/Data-String.html#t:String">String</a> a <a href="src/Tutorial.html#parse" class="link">Source</a> <a href="#v:parse" class="selflink">#</a></p><div class="doc"><p>All you do to run a parser is pull the function out of
 the <code><a href="Tutorial.html#t:Parse">Parse</a></code> type, run it on the string, and drop the leftovers
 It would be nice to have it return an error, but it would get
 more messy and this is supposed to be a pretty clean introduction.</p><p>Here's a verbose implementation:</p><pre> <code><a href="Tutorial.html#v:parse">parse</a></code> (<code><a href="Tutorial.html#v:Parser">Parser</a></code> p) s = mapEither onlySecond (p s)
</pre><p>or my actual Haskell implementaion:</p><pre> <code><a href="Tutorial.html#v:parse">parse</a></code> = <code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> (<code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> <code><a href="../base-4.9.1.0/Data-Tuple.html#v:snd">snd</a></code>) <code><a href="../base-4.9.1.0/Data-Function.html#v:.">.</a></code> <code><a href="Tutorial.html#v:runParser">runParser</a></code>
</pre></div></div><div class="doc"><p>Ok, so we have a nice background on Functors, Applicatives, Monads, and how they apply to parsing.
 Now what? I'll begin by defining a single parser &quot;by hand&quot; (without all these nice classes) and show
 what can be done with it.</p></div><div class="top"><p class="src"><a id="v:charP" class="def">charP</a> :: (<a href="../base-4.9.1.0/Data-Char.html#t:Char">Char</a> -&gt; <a href="../base-4.9.1.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="Tutorial.html#t:Parse">Parse</a> <a href="../base-4.9.1.0/Data-Char.html#t:Char">Char</a> <a href="src/Tutorial.html#charP" class="link">Source</a> <a href="#v:charP" class="selflink">#</a></p><div class="doc"><p>Accept any <code><a href="../base-4.9.1.0/Data-Char.html#t:Char">Char</a></code> the predicate passes for
 Here's how this works: <code><a href="Tutorial.html#v:charP">charP</a></code> takes a test or &quot;predicate&quot;.</p><p>When the parser is run, if the test passes for the first character in the string
 then return the character and the rest of the string as leftover.
 If the test fails or there is no first character, then it fails.</p><pre> <code><a href="Tutorial.html#v:charP">charP</a></code> p = <code><a href="Tutorial.html#v:Parser">Parser</a></code> go
   where
     go [] = <code><a href="../base-4.9.1.0/Data-Either.html#v:Left">Left</a></code> []
     go (c:cs) | p c       = <code><a href="../base-4.9.1.0/Data-Either.html#v:Right">Right</a></code> (cs, c )
               | <code><a href="../base-4.9.1.0/Data-Bool.html#v:otherwise">otherwise</a></code> = <code><a href="../base-4.9.1.0/Data-Either.html#v:Left">Left</a></code>  (c : cs)
</pre></div></div><div class="top"><p class="src"><a id="v:char" class="def">char</a> :: <a href="../base-4.9.1.0/Data-Char.html#t:Char">Char</a> -&gt; <a href="Tutorial.html#t:Parse">Parse</a> <a href="../base-4.9.1.0/Data-Char.html#t:Char">Char</a> <a href="src/Tutorial.html#char" class="link">Source</a> <a href="#v:char" class="selflink">#</a></p><div class="doc"><p>Match the specified <code><a href="../base-4.9.1.0/Data-Char.html#t:Char">Char</a></code></p><p>(This is just <code><code><a href="Tutorial.html#v:charP">charP</a></code> (<code><a href="../base-4.9.1.0/Data-Eq.html#v:-61--61-">==</a></code> givenCharacter)</code>)</p><pre> <code><a href="Tutorial.html#v:char">char</a></code> = <code><a href="Tutorial.html#v:charP">charP</a></code> <code><a href="../base-4.9.1.0/Data-Function.html#v:.">.</a></code> (<code><a href="../base-4.9.1.0/Data-Eq.html#v:-61--61-">==</a></code>)
</pre></div></div><div class="top"><p class="src"><a id="v:digit" class="def">digit</a> :: <a href="Tutorial.html#t:Parse">Parse</a> <a href="../base-4.9.1.0/Data-Char.html#t:Char">Char</a> <a href="src/Tutorial.html#digit" class="link">Source</a> <a href="#v:digit" class="selflink">#</a></p><div class="doc"><p>Match any digit `Char</p><pre> <code><a href="Tutorial.html#v:digit">digit</a></code> = <code><a href="Tutorial.html#v:charP">charP</a></code> <code><a href="../base-4.9.1.0/Data-Char.html#v:isDigit">isDigit</a></code>
</pre></div></div><div class="top"><p class="src"><a id="v:anyChar" class="def">anyChar</a> :: <a href="Tutorial.html#t:Parse">Parse</a> <a href="../base-4.9.1.0/Data-Char.html#t:Char">Char</a> <a href="src/Tutorial.html#anyChar" class="link">Source</a> <a href="#v:anyChar" class="selflink">#</a></p><div class="doc"><p>Since <code><code><a href="../base-4.9.1.0/Data-Function.html#v:const">const</a></code> <code><a href="../base-4.9.1.0/Data-Bool.html#v:True">True</a></code></code> is a function that always returns <code><a href="../base-4.9.1.0/Data-Bool.html#v:True">True</a></code>,
 this parses any single character</p><pre> <code><a href="Tutorial.html#v:anyChar">anyChar</a></code> = <code><a href="Tutorial.html#v:charP">charP</a></code> (<code><a href="../base-4.9.1.0/Data-Function.html#v:const">const</a></code> <code><a href="../base-4.9.1.0/Data-Bool.html#v:True">True</a></code>)
</pre></div></div><div class="top"><p class="src"><a id="v:notP" class="def">notP</a> :: <a href="Tutorial.html#t:Parse">Parse</a> a -&gt; <a href="Tutorial.html#t:Parse">Parse</a> () <a href="src/Tutorial.html#notP" class="link">Source</a> <a href="#v:notP" class="selflink">#</a></p><div class="doc"><p>Succeeds only if the provided parser fails
 (does not consume any input).
 What this does is run the given parser (<code>p</code>):</p><p>If <code>p</code> succeeds, then this parser fails, rewinding the input to before <code>p</code></p><p>If <code>p</code> fails, then this parser succeeds and returns all of the input as leftovers</p><p>Note that we never defined <code><a href="../base-4.9.1.0/Data-Traversable.html#v:mapM">mapM</a></code>. That's because we get it for free by defining <code><a href="../base-4.9.1.0/Control-Monad.html#v:return">return</a></code> and (<code><a href="../base-4.9.1.0/Control-Monad.html#v:-62--62--61-">&gt;&gt;=</a></code>).</p><pre><code><a href="Tutorial.html#v:notP">notP</a></code> p = <code><a href="Tutorial.html#v:Parser">Parser</a></code> $ <code><a href="Tutorial.html#v:runParser">runParser</a></code> p <code><a href="../base-4.9.1.0/Control-Monad.html#v:-62--62--61-">&gt;&gt;=</a></code> go
  where
    go (<code><a href="../base-4.9.1.0/Data-Either.html#v:Left">Left</a></code> _) s = <code><a href="../base-4.9.1.0/Data-Either.html#v:Right">Right</a></code> (s, `()`)
    go       _  s = <code><a href="../base-4.9.1.0/Data-Either.html#v:Left">Left</a></code>   s
</pre></div></div><div class="top"><p class="src"><a id="v:string" class="def">string</a> :: <a href="../base-4.9.1.0/Data-String.html#t:String">String</a> -&gt; <a href="Tutorial.html#t:Parse">Parse</a> <a href="../base-4.9.1.0/Data-String.html#t:String">String</a> <a href="src/Tutorial.html#string" class="link">Source</a> <a href="#v:string" class="selflink">#</a></p><div class="doc"><p><code><a href="../base-4.9.1.0/Data-Traversable.html#v:mapM">mapM</a></code> maps the function and combines all the monads inside.</p><p>For example:</p><pre> <code><a href="../base-4.9.1.0/GHC-OldList.html#v:map">map</a></code> <code><a href="Tutorial.html#v:char">char</a></code> [<code>a</code>, <code>b</code>, <code>c</code>] = [<code><a href="Tutorial.html#v:char">char</a></code> <code>a</code>, <code><a href="Tutorial.html#v:char">char</a></code> <code>b</code>, <code><a href="Tutorial.html#v:char">char</a></code> <code>c</code>]
</pre><p>This isn't too helpful since now we have to somehow run all the <code><a href="Tutorial.html#v:char">char</a></code>
 parsers and collect the results. <code><a href="../base-4.9.1.0/Data-Traversable.html#v:mapM">mapM</a></code> does exactly this (remember that <code><code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code> = [<code><a href="../base-4.9.1.0/Data-Char.html#t:Char">Char</a></code>]</code>).</p><pre> <code><a href="Tutorial.html#v:string">string</a></code> = <code><a href="../base-4.9.1.0/Data-Traversable.html#v:mapM">mapM</a></code> <code><a href="Tutorial.html#v:char">char</a></code>
</pre></div></div><div class="top"><p class="src"><a id="v:elemP" class="def">elemP</a> :: <a href="../base-4.9.1.0/Data-String.html#t:String">String</a> -&gt; <a href="Tutorial.html#t:Parse">Parse</a> <a href="../base-4.9.1.0/Data-Char.html#t:Char">Char</a> <a href="src/Tutorial.html#elemP" class="link">Source</a> <a href="#v:elemP" class="selflink">#</a></p><div class="doc"><p>Parse any <code><a href="../base-4.9.1.0/Data-Char.html#t:Char">Char</a></code> in the given <code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code></p></div></div><div class="top"><p class="src"><a id="v:-60--60-" class="def">(&lt;&lt;)</a> :: <a href="../base-4.9.1.0/Control-Monad.html#t:Monad">Monad</a> m =&gt; m a -&gt; m b -&gt; m a <a href="src/Tutorial.html#%3C%3C" class="link">Source</a> <a href="#v:-60--60-" class="selflink">#</a></p><div class="doc"><p>One more function, this one is also free from <code><a href="../base-4.9.1.0/Control-Monad.html#v:return">return</a></code> and (<code><a href="../base-4.9.1.0/Control-Monad.html#v:-62--62--61-">&gt;&gt;=</a></code>):</p><p><code>parseA <code><a href="../base-4.9.1.0/Control-Monad.html#v:-62--62-">&gt;&gt;</a></code> parseB</code> parses A, but tosses the result before parsing B</p><pre>(&gt;&gt;) :: <code><a href="Tutorial.html#t:Parse">Parse</a></code> a -&gt; <code><a href="Tutorial.html#t:Parse">Parse</a></code> b -&gt; <code><a href="Tutorial.html#t:Parse">Parse</a></code> b
</pre><p>This is like (<code><a href="../base-4.9.1.0/Control-Monad.html#v:-62--62-">&gt;&gt;</a></code>), but backwards.</p><p><code>parseA <code><a href="Tutorial.html#v:-60--60-">&lt;&lt;</a></code> parseB</code> parses A, then B, but tosses B</p><p>If you want to understand how it works:</p><pre><code><a href="../base-4.9.1.0/Control-Monad.html#v:liftM2">liftM2</a></code> :: (a -&gt; b -&gt; c) -&gt; <code><a href="Tutorial.html#t:Parse">Parse</a></code> a -&gt; <code><a href="Tutorial.html#t:Parse">Parse</a></code> b -&gt; <code><a href="Tutorial.html#t:Parse">Parse</a></code> c
<code><a href="../base-4.9.1.0/Control-Monad.html#v:liftM2">liftM2</a></code> func parser1 parser2 = run parser1, run parser2, return their results combined with func
</pre><p>Now <code><code><a href="../base-4.9.1.0/Control-Monad.html#v:liftM2">liftM2</a></code> <code><a href="../base-4.9.1.0/Data-Function.html#v:const">const</a></code></code> makes sense. It runs both parsers, but <code><code><a href="../base-4.9.1.0/Data-Function.html#v:const">const</a></code> a b = a</code>
 so it tosses the result of the second parser.</p><pre>(<code><a href="Tutorial.html#v:-60--60-">&lt;&lt;</a></code>) = <code><a href="../base-4.9.1.0/Control-Monad.html#v:liftM2">liftM2</a></code> <code><a href="../base-4.9.1.0/Data-Function.html#v:const">const</a></code>
</pre></div></div><div class="top"><p class="src"><a id="v:space" class="def">space</a> :: <a href="Tutorial.html#t:Parse">Parse</a> <a href="../base-4.9.1.0/Data-Char.html#t:Char">Char</a> <a href="src/Tutorial.html#space" class="link">Source</a> <a href="#v:space" class="selflink">#</a></p><div class="doc"><p>Parse any single space</p><pre> <code><a href="Tutorial.html#v:space">space</a></code> = <code><a href="Tutorial.html#v:charP">charP</a></code> <code><a href="../base-4.9.1.0/Data-Char.html#v:isSpace">isSpace</a></code>
</pre></div></div><div class="top"><p class="src"><a id="v:inParens" class="def">inParens</a> :: <a href="Tutorial.html#t:Parse">Parse</a> a -&gt; <a href="Tutorial.html#t:Parse">Parse</a> a <a href="src/Tutorial.html#inParens" class="link">Source</a> <a href="#v:inParens" class="selflink">#</a></p><div class="doc"><p>Isn't this pretty?</p><pre> <code><a href="Tutorial.html#v:inParens">inParens</a></code> p = <code><a href="Tutorial.html#v:char">char</a></code> '(' <code><a href="../base-4.9.1.0/Control-Monad.html#v:-62--62-">&gt;&gt;</a></code> p <code><a href="Tutorial.html#v:-60--60-">&lt;&lt;</a></code> <code><a href="Tutorial.html#v:char">char</a></code> ')'
</pre></div></div><div class="top"><p class="src"><a id="v:word" class="def">word</a> :: <a href="Tutorial.html#t:Parse">Parse</a> <a href="../base-4.9.1.0/Data-String.html#t:String">String</a> <a href="src/Tutorial.html#word" class="link">Source</a> <a href="#v:word" class="selflink">#</a></p><div class="doc"><p>Parse a series of alpha characters</p><pre> <code><a href="Tutorial.html#v:word">word</a></code> = <code><a href="../base-4.9.1.0/Control-Applicative.html#v:some">some</a></code> <code><a href="../base-4.9.1.0/Data-Function.html#v:-36-">$</a></code> <code><a href="Tutorial.html#v:charP">charP</a></code> <code><a href="../base-4.9.1.0/Data-Char.html#v:isAlpha">isAlpha</a></code>
</pre></div></div><div class="top"><p class="src"><a id="v:name" class="def">name</a> :: <a href="Tutorial.html#t:Parse">Parse</a> <a href="../base-4.9.1.0/Data-String.html#t:String">String</a> <a href="src/Tutorial.html#name" class="link">Source</a> <a href="#v:name" class="selflink">#</a></p><div class="doc"><p>In words: &quot;the input must start with 'Name ', but once we know it's there, just toss it and parse a word&quot;</p><pre> <code><a href="Tutorial.html#v:name">name</a></code> = <code><a href="Tutorial.html#v:string">string</a></code> &quot;Name &quot; <code><a href="../base-4.9.1.0/Control-Monad.html#v:-62--62-">&gt;&gt;</a></code> <code><a href="Tutorial.html#v:word">word</a></code>
</pre></div></div><div class="top"><p class="src"><a id="v:classType" class="def">classType</a> :: <a href="Tutorial.html#t:Parse">Parse</a> (<a href="../base-4.9.1.0/Data-String.html#t:String">String</a>, <a href="../base-4.9.1.0/Data-String.html#t:String">String</a>) <a href="src/Tutorial.html#classType" class="link">Source</a> <a href="#v:classType" class="selflink">#</a></p><div class="doc"><p>Now let's write a simple parser for something like</p><pre> &quot;Class (Name NamedThing)&quot;
</pre><p>where we only want <a href="Class.html">Class</a> and <a href="NamedThing.html">NamedThing</a>:</p><pre> <code><a href="Tutorial.html#v:classType">classType</a></code> = do
   className &lt;- <code><a href="Tutorial.html#v:word">word</a></code>            -- get a word and call it <code>className</code>
   <code><a href="../base-4.9.1.0/Control-Applicative.html#v:many">many</a></code> <code><a href="Tutorial.html#v:space">space</a></code>                   -- get a bunch of spaces, but toss them, they're in the way
   typeName  &lt;- <code><a href="Tutorial.html#v:inParens">inParens</a></code> <code><a href="Tutorial.html#v:name">name</a></code>   -- get a name that's in parentheses and call it <code>typeName</code>
   <code><a href="../base-4.9.1.0/Control-Monad.html#v:return">return</a></code> (className, typeName)  -- return what you've gotten in a nice tuple
</pre><p>examples: (almost exact)</p><pre>parse classType &quot;Spoken  (Name Kid)&quot;      = (<a href="Spoken.html">Spoken</a>, <a href="Kid.html">Kid</a>)
parse classType &quot;Monad   (Name Function)&quot; = (<a href="Monad.html">Monad</a>,  <a href="Function.html">Function</a>)
parse classType &quot;Word1   (Name Word2)&quot;    = (<a href="Word1.html">Word1</a>,  <a href="Word2.html">Word2</a>)
</pre></div></div><h2 id="g:8">Writing a recursive parser</h2><div class="doc"><p>Ok, so that wasn't bad. However, it's also not too hard to parse something like that in the first place.
 How about parsing a lisp that only supports addition of natural numbers? Huh, that could be neat.</p><p>Here's what I invision it looking like:</p><pre> 1 -&gt; 1
 (+ 2 2) -&gt; 4
 (+ (+ 1 2) (+ 3 4)) -&gt; 10
</pre><p>For completion sake, we define: <code>(+ x) -&gt; x</code> and make <code>(+)</code> or <code>()</code> a parse error.</p><p>First, let's define our expression type:</p><p>This is a GADT, but that's for another time. It could easily be defined as the following:</p><pre> data <code><a href="Tutorial.html#t:Expr">Expr</a></code> a = <code><a href="Tutorial.html#v:Lit">Lit</a></code> a | <code><a href="Tutorial.html#v:Sum">Sum</a></code> [<code><a href="Tutorial.html#t:Expr">Expr</a></code> a]
</pre><p>But I prefer the GADT style:</p><pre> data <code><a href="Tutorial.html#t:Expr">Expr</a></code> a where
   <code><a href="Tutorial.html#v:Lit">Lit</a></code> ::       a  -&gt; <code><a href="Tutorial.html#t:Expr">Expr</a></code> a
   <code><a href="Tutorial.html#v:Sum">Sum</a></code> :: [<code><a href="Tutorial.html#t:Expr">Expr</a></code> a] -&gt; <code><a href="Tutorial.html#t:Expr">Expr</a></code> a
</pre></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Expr" class="def">Expr</a> a <span class="keyword">where</span> <a href="src/Tutorial.html#Expr" class="link">Source</a> <a href="#t:Expr" class="selflink">#</a></p><div class="doc"><p>An Expression with type <code>a</code> can be:</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Lit" class="def">Lit</a> :: a -&gt; <a href="Tutorial.html#t:Expr">Expr</a> a</td><td class="doc"><p>A numeric literal, e.g. <code>1337</code> or <code>42</code></p></td></tr><tr><td class="src"><a id="v:Sum" class="def">Sum</a> :: [<a href="Tutorial.html#t:Expr">Expr</a> a] -&gt; <a href="Tutorial.html#t:Expr">Expr</a> a</td><td class="doc"><p>A sum of expressions</p></td></tr></table></div><div class="subs instances"><p id="control.i:Expr" class="caption collapser" onclick="toggleSection('i:Expr')">Instances</p><div id="section.i:Expr" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Expr:Eq:1" class="instance expander" onclick="toggleSection('i:id:Expr:Eq:1')"></span> <a href="../base-4.9.1.0/Data-Eq.html#t:Eq">Eq</a> a =&gt; <a href="../base-4.9.1.0/Data-Eq.html#t:Eq">Eq</a> (<a href="Tutorial.html#t:Expr">Expr</a> a)</span> <a href="src/Tutorial.html#line-926" class="link">Source</a> <a href="#t:Expr" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:Expr:Eq:1" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="Tutorial.html#t:Expr">Expr</a> a -&gt; <a href="Tutorial.html#t:Expr">Expr</a> a -&gt; <a href="../base-4.9.1.0/Data-Bool.html#t:Bool">Bool</a> <a href="#v:-61--61-" class="selflink">#</a></p><p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="Tutorial.html#t:Expr">Expr</a> a -&gt; <a href="Tutorial.html#t:Expr">Expr</a> a -&gt; <a href="../base-4.9.1.0/Data-Bool.html#t:Bool">Bool</a> <a href="#v:-47--61-" class="selflink">#</a></p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Expr:Ord:2" class="instance expander" onclick="toggleSection('i:id:Expr:Ord:2')"></span> <a href="../base-4.9.1.0/Data-Ord.html#t:Ord">Ord</a> a =&gt; <a href="../base-4.9.1.0/Data-Ord.html#t:Ord">Ord</a> (<a href="Tutorial.html#t:Expr">Expr</a> a)</span> <a href="src/Tutorial.html#line-926" class="link">Source</a> <a href="#t:Expr" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:Expr:Ord:2" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:compare">compare</a> :: <a href="Tutorial.html#t:Expr">Expr</a> a -&gt; <a href="Tutorial.html#t:Expr">Expr</a> a -&gt; <a href="../base-4.9.1.0/Data-Ord.html#t:Ordering">Ordering</a> <a href="#v:compare" class="selflink">#</a></p><p class="src"><a href="#v:-60-">(&lt;)</a> :: <a href="Tutorial.html#t:Expr">Expr</a> a -&gt; <a href="Tutorial.html#t:Expr">Expr</a> a -&gt; <a href="../base-4.9.1.0/Data-Bool.html#t:Bool">Bool</a> <a href="#v:-60-" class="selflink">#</a></p><p class="src"><a href="#v:-60--61-">(&lt;=)</a> :: <a href="Tutorial.html#t:Expr">Expr</a> a -&gt; <a href="Tutorial.html#t:Expr">Expr</a> a -&gt; <a href="../base-4.9.1.0/Data-Bool.html#t:Bool">Bool</a> <a href="#v:-60--61-" class="selflink">#</a></p><p class="src"><a href="#v:-62-">(&gt;)</a> :: <a href="Tutorial.html#t:Expr">Expr</a> a -&gt; <a href="Tutorial.html#t:Expr">Expr</a> a -&gt; <a href="../base-4.9.1.0/Data-Bool.html#t:Bool">Bool</a> <a href="#v:-62-" class="selflink">#</a></p><p class="src"><a href="#v:-62--61-">(&gt;=)</a> :: <a href="Tutorial.html#t:Expr">Expr</a> a -&gt; <a href="Tutorial.html#t:Expr">Expr</a> a -&gt; <a href="../base-4.9.1.0/Data-Bool.html#t:Bool">Bool</a> <a href="#v:-62--61-" class="selflink">#</a></p><p class="src"><a href="#v:max">max</a> :: <a href="Tutorial.html#t:Expr">Expr</a> a -&gt; <a href="Tutorial.html#t:Expr">Expr</a> a -&gt; <a href="Tutorial.html#t:Expr">Expr</a> a <a href="#v:max" class="selflink">#</a></p><p class="src"><a href="#v:min">min</a> :: <a href="Tutorial.html#t:Expr">Expr</a> a -&gt; <a href="Tutorial.html#t:Expr">Expr</a> a -&gt; <a href="Tutorial.html#t:Expr">Expr</a> a <a href="#v:min" class="selflink">#</a></p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Expr:Arbitrary:3" class="instance expander" onclick="toggleSection('i:id:Expr:Arbitrary:3')"></span> (<a href="../base-4.9.1.0/Prelude.html#t:Num">Num</a> a, <a href="../base-4.9.1.0/Data-Ord.html#t:Ord">Ord</a> a, <a href="../QuickCheck-2.9.2/Test-QuickCheck-Arbitrary.html#t:Arbitrary">Arbitrary</a> a) =&gt; <a href="../QuickCheck-2.9.2/Test-QuickCheck-Arbitrary.html#t:Arbitrary">Arbitrary</a> (<a href="Tutorial.html#t:Expr">Expr</a> a)</span> <a href="src/Tutorial.html#line-154" class="link">Source</a> <a href="#t:Expr" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:Expr:Arbitrary:3" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:arbitrary">arbitrary</a> :: <a href="../QuickCheck-2.9.2/Test-QuickCheck-Gen.html#t:Gen">Gen</a> (<a href="Tutorial.html#t:Expr">Expr</a> a) <a href="#v:arbitrary" class="selflink">#</a></p><p class="src"><a href="#v:shrink">shrink</a> :: <a href="Tutorial.html#t:Expr">Expr</a> a -&gt; [<a href="Tutorial.html#t:Expr">Expr</a> a] <a href="#v:shrink" class="selflink">#</a></p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Expr:CoArbitrary:4" class="instance expander" onclick="toggleSection('i:id:Expr:CoArbitrary:4')"></span> <a href="../QuickCheck-2.9.2/Test-QuickCheck-Arbitrary.html#t:CoArbitrary">CoArbitrary</a> a =&gt; <a href="../QuickCheck-2.9.2/Test-QuickCheck-Arbitrary.html#t:CoArbitrary">CoArbitrary</a> (<a href="Tutorial.html#t:Expr">Expr</a> a)</span> <a href="src/Tutorial.html#line-160" class="link">Source</a> <a href="#t:Expr" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:Expr:CoArbitrary:4" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:coarbitrary">coarbitrary</a> :: <a href="Tutorial.html#t:Expr">Expr</a> a -&gt; <a href="../QuickCheck-2.9.2/Test-QuickCheck-Gen.html#t:Gen">Gen</a> b -&gt; <a href="../QuickCheck-2.9.2/Test-QuickCheck-Gen.html#t:Gen">Gen</a> b <a href="#v:coarbitrary" class="selflink">#</a></p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Expr:EqProp:5" class="instance expander" onclick="toggleSection('i:id:Expr:EqProp:5')"></span> <a href="../base-4.9.1.0/Data-Eq.html#t:Eq">Eq</a> a =&gt; <a href="../checkers-0.4.6/Test-QuickCheck-Checkers.html#t:EqProp">EqProp</a> (<a href="Tutorial.html#t:Expr">Expr</a> a)</span> <a href="src/Tutorial.html#line-143" class="link">Source</a> <a href="#t:Expr" class="selflink">#</a></td><td class="doc"><p>Just use the derived <code><a href="../base-4.9.1.0/Data-Eq.html#t:Eq">Eq</a></code> instance</p></td></tr><tr><td colspan="2"><div id="section.i:id:Expr:EqProp:5" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61--45--61-">(=-=)</a> :: <a href="Tutorial.html#t:Expr">Expr</a> a -&gt; <a href="Tutorial.html#t:Expr">Expr</a> a -&gt; <a href="../QuickCheck-2.9.2/Test-QuickCheck-Property.html#t:Property">Property</a> <a href="#v:-61--45--61-" class="selflink">#</a></p></div></div></td></tr></table></div></div></div><div class="top"><p class="src"><a id="v:parseLit" class="def">parseLit</a> :: <a href="../base-4.9.1.0/Prelude.html#t:Num">Num</a> a =&gt; <a href="Tutorial.html#t:Parse">Parse</a> (<a href="Tutorial.html#t:Expr">Expr</a> a) <a href="src/Tutorial.html#parseLit" class="link">Source</a> <a href="#v:parseLit" class="selflink">#</a></p><div class="doc"><p>A literal is:</p><pre> <code><a href="Tutorial.html#v:parseLit">parseLit</a></code> = do
   <code><a href="../base-4.9.1.0/Control-Applicative.html#v:some">some</a></code> <code><a href="Tutorial.html#v:space">space</a></code>                           -- toss some spaces
   digits &lt;- <code><a href="../base-4.9.1.0/Control-Applicative.html#v:some">some</a></code> <code><a href="Tutorial.html#v:digit">digit</a></code>                 -- the literal's digits are just &quot;some digits&quot;
   <code><a href="../base-4.9.1.0/Control-Monad.html#v:return">return</a></code> <code><a href="../base-4.9.1.0/Data-Function.html#v:.">.</a></code> <code><a href="Tutorial.html#v:Lit">Lit</a></code> <code><a href="../base-4.9.1.0/Data-Function.html#v:.">.</a></code> toNum <code><a href="../base-4.9.1.0/Data-Function.html#v:.">.</a></code> <code><a href="../base-4.9.1.0/Text-Read.html#v:read">read</a></code> <code><a href="../base-4.9.1.0/Data-Function.html#v:-36-">$</a></code> digits -- return the digits, read and converted to a nice <code><a href="../base-4.9.1.0/Prelude.html#t:Num">Num</a></code> type, then wrapped in the <code><a href="Tutorial.html#v:Lit">Lit</a></code> constructor
     where
       toNum :: <code><a href="../base-4.9.1.0/Prelude.html#t:Num">Num</a></code> a =&gt; <code><a href="../base-4.9.1.0/Data-Int.html#t:Int">Int</a></code> -&gt; a
       toNum = <code><a href="../base-4.9.1.0/Prelude.html#v:fromInteger">fromInteger</a></code> <code><a href="../base-4.9.1.0/Data-Function.html#v:.">.</a></code> <code><a href="../base-4.9.1.0/Prelude.html#v:toEnum">toEnum</a></code>
</pre></div></div><div class="top"><p class="src"><a id="v:parseSum" class="def">parseSum</a> :: <a href="../base-4.9.1.0/Prelude.html#t:Num">Num</a> a =&gt; <a href="Tutorial.html#t:Parse">Parse</a> (<a href="Tutorial.html#t:Expr">Expr</a> a) <a href="src/Tutorial.html#parseSum" class="link">Source</a> <a href="#v:parseSum" class="selflink">#</a></p><div class="doc"><p>A sum is:</p><pre> <code><a href="Tutorial.html#v:parseSum">parseSum</a></code> = do
   <code><a href="Tutorial.html#v:char">char</a></code> '('                     -- starts with an opening parentheses
   <code><a href="Tutorial.html#v:char">char</a></code> '+'                       -- then there's a <code><a href="../base-4.9.1.0/Prelude.html#v:-43-">+</a></code>
   subExprs &lt;- <code><a href="../base-4.9.1.0/Control-Applicative.html#v:some">some</a></code> <code><a href="Tutorial.html#v:parseExpr">parseExpr</a></code>   -- then there are some subexpressions, each one is either a literal or a sum
   <code><a href="Tutorial.html#v:char">char</a></code> ')'                     -- end with a closing parentheses
   <code><a href="../base-4.9.1.0/Control-Monad.html#v:return">return</a></code> <code><a href="../base-4.9.1.0/Data-Function.html#v:-36-">$</a></code> <code><a href="Tutorial.html#v:Sum">Sum</a></code> subExprs        -- return the subexpressions wrapped in our <code><a href="Tutorial.html#v:Sum">Sum</a></code> constructor
</pre></div></div><div class="top"><p class="src"><a id="v:parseExpr" class="def">parseExpr</a> :: <a href="../base-4.9.1.0/Prelude.html#t:Num">Num</a> a =&gt; <a href="Tutorial.html#t:Parse">Parse</a> (<a href="Tutorial.html#t:Expr">Expr</a> a) <a href="src/Tutorial.html#parseExpr" class="link">Source</a> <a href="#v:parseExpr" class="selflink">#</a></p><div class="doc"><p>An expression is:</p><pre> <code><a href="Tutorial.html#v:parseExpr">parseExpr</a></code> = <code><a href="Tutorial.html#v:parseLit">parseLit</a></code> <a href="|">|</a> <code><a href="Tutorial.html#v:parseSum">parseSum</a></code> -- either a literal or a sum
</pre></div></div><div class="doc"><p>Well, that was easy. Let's make a quick evaluator:</p></div><div class="top"><p class="src"><a id="v:eval" class="def">eval</a> :: <a href="../base-4.9.1.0/Prelude.html#t:Num">Num</a> a =&gt; <a href="Tutorial.html#t:Expr">Expr</a> a -&gt; a <a href="src/Tutorial.html#eval" class="link">Source</a> <a href="#v:eval" class="selflink">#</a></p><div class="doc"><p>To evaluate an expression:</p><pre> <code><a href="Tutorial.html#v:eval">eval</a></code> (<code><a href="Tutorial.html#v:Lit">Lit</a></code> x ) = x                  -- we unwrap literals
 <code><a href="Tutorial.html#v:eval">eval</a></code> (<code><a href="Tutorial.html#v:Sum">Sum</a></code> xs) = <code><a href="../base-4.9.1.0/Data-Foldable.html#v:sum">sum</a></code> (<code><a href="../base-4.9.1.0/Data-Functor.html#v:fmap">fmap</a></code> <code><a href="Tutorial.html#v:eval">eval</a></code> xs) -- and sum the evaluated subexpressions in a <code><a href="Tutorial.html#v:Sum">Sum</a></code>
</pre></div></div><div class="doc"><p>Ok, so that was easy too. I'm gonna go off and extend this until it gets hard.</p></div><div class="top"><p class="src"><a id="v:toParser" class="def">toParser</a> :: (<a href="../base-4.9.1.0/Data-String.html#t:String">String</a> -&gt; (<a href="../base-4.9.1.0/Data-Bool.html#t:Bool">Bool</a>, <a href="../base-4.9.1.0/Data-Int.html#t:Int">Int</a>, a)) -&gt; <a href="Tutorial.html#t:Parse">Parse</a> a <a href="src/Tutorial.html#toParser" class="link">Source</a> <a href="#v:toParser" class="selflink">#</a></p><div class="doc"><p>(This is for the test suite, but defined here because I haven't moved it yet.) Convert a</p><pre> <code><a href="../base-4.9.1.0/Data-String.html#t:String">String</a></code> -&gt; (<code><a href="../base-4.9.1.0/Data-Bool.html#t:Bool">Bool</a></code>, <code><a href="../base-4.9.1.0/Data-Int.html#t:Int">Int</a></code>, a)
</pre><p>function into a parser by:</p><ul><li>If the <code><a href="../base-4.9.1.0/Data-Bool.html#t:Bool">Bool</a></code> is <code><a href="../base-4.9.1.0/Data-Bool.html#v:False">False</a></code>, consume no input</li><li>If the <code><a href="../base-4.9.1.0/Data-Bool.html#t:Bool">Bool</a></code> is <code><a href="../base-4.9.1.0/Data-Bool.html#v:True">True</a></code>, consume the <code><a href="../base-4.9.1.0/Data-Int.html#t:Int">Int</a></code> characters of input if available, else fail</li></ul></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.17.3</p></div></body></html>